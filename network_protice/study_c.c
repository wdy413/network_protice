#pragma once
/*
https://blog.csdn.net/weixin_44617968/article/details/117661182
常量
	单精度小数:以字母f或字母F结尾。例如:0.0f、1.01f
	可以没有整数位只有小数位。例如: .3、 .6f

	用C语言表示就是1.23e5或1.23E5

	特殊情况: 如果是转义字符,单引号中可以有两个字符。例如:'\n'、'\t'

	字符型常量都是用""(双引号)括起来的。例如:“a”、“abc”、“lnj”
	系统会自动在字符串常量的末尾加一个字符'\0’作为字符串结束标志

变量初始化
	不初始化里面存储什么?随机数、上次程序分配的存储空间内容、系统正在用的一些数据

putchar和getchar
	putchar: 向屏幕输出一个字符
	getchar: 从键盘获得一个字符

二维数组
	定义的同时初始化int a[2][3]={ {80,75,92}, {61,65,71}};
	完全初始化,可以省略第一维的长度int a[][3]={1,2,3,4,5,6};当直接给出初始化的值时第一维才能忽略，先定义再初始化时不能省略

字符串
	在C语言中没有专门的字符串变量,通常用一个字符数组来存放一个字符串。
	当把一个字符串存入一个数组时,会把结束符‘\0’存入数组,并以此作为该字符串是否结束的标志。
	有了‘\0’标志后,就不必再用字符数组 的长度来判断字符串的长度了 char name1[9] = {'l','n','j','\0'};
	字符串数组其实就是定义一个数组保存所有的字符串char names3[2][10] = { "lnj", "lyh" };
	char string[]="I love lnj!";

指针
	在不是定义变量的时候 *是一个操作符,代表访问指针所指向存储空间
	在同一种编译器下, 所有指针占用的内存空间是一样的,但不同类型的变量却占不同的字节数
	如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针变量。也称为“二级指针”char **cp2;
	
	指针与数组
		一个数组包含若干元素,每个数组元素也有相应的地址, 指针变量也可以保存数组元素的地址，首位元素地址
		int* p;p=&a[0];等价于p=a数组名a不代表整个数组,只代表数组首元素的地址
		数组名虽然是数组的首地址，但是数组名所所保存的数组的首地址是不可以更改的,指针的值可以更改
	
	指针与字符串
		字符串指针指向字符串首地址
		使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以不可以修改字符串中的字符
		不能够直接接收键盘输入，野指针并没有指向某一块内存空间

	指向函数指针
		int (*p)(int,int);p = sum;

结构体
	结构体数组
		结构体数组初始化和普通数组也一样, 分为先定义后初始化和定义同时初始化struct Student stu[2] = {{"lnj", 35},{"zs", 18}}; 

	结构体指针
		printf("name=%s, age = %d \n", (*p).name, (*p).age);
		printf("name=%s, age = %d \n", p->name, p->age);
	结构体内存分析
		结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)
		给结构体变量开辟存储空间和给普通开辟存储空间一样, 按照定义顺序
		给数组元素开辟存储空间一样, 会从所占用内存地址小的位置开始开辟
	结构体嵌套
		如果某个成员也是结构体变量，可以连续使用成员运算符"."访问最低一级成员
	结构体与函数
		结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递
		所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参

共用体
	共用体所有的成员都占用同一块存储空间
	由于所有属性共享同一块内存空间, 所以只要其中一个属性发生了改变, 其它的属性都会受到影响
	通信中的数据包会用到共用体
	节约内存
枚举
	C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量
	枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1
全局和局部变量
	局部变量存储位置: 局部变量会存储在内存的栈区中
	全局变量存储位置：静态存储区
auto和register
	auto只能修饰局部变量, 局部变量如果没有其它修饰符, 默认就是auto的
	register只能修饰局部变量, 原则上将内存中变量提升到CPU寄存器中存储, 这样访问速度会更快，但是由于CPU寄存器数量相当有限, 通常不同平台和编译器在优化阶段会自动转换为auto
static关键字
	在全局范围内声明的变量（即在函数外部声明的变量），则将其作用域限定在声明它的文件中，即它是一个文件作用域的全局变量
	在局部变量中，在函数内部声明的变量，如果加上 static 关键字，则将其生命周期延长到整个程序运行期间，而不是函数执行期间。它仍然是局部变量，只能在声明它的函数内部访问，但其值在函数调用之间保持不变。
	static 关键字在全局变量中将作用域限定在当前文件，不影响其存储方式，仍然存储在静态存储区
	在函数前定义为内部函数:只能在本文件中访问的函数
extern关键字
	声明一个全局变量, 代表告诉编译器我在其它地方定义了这个变量, 可以放心使用
	extern代表声明一个变量, 而不是定义一个变量, 变量只有定义才会开辟存储空间
	外部函数:可以在本文件中以及其他的文件中访问的函数，默认情况下所有的函数都是外部函数
	如果只有函数声明添加了static与extern, 而定义中没有添加static与extern, 那么无效，函数的声明和定义是区分的
编译过程
	对源文件进行预处理, 生成预处理文件.i
	对预处理文件进行编译, 生成汇编文件.s
	对汇编文件进行编译, 生成二进制文件.o
	对二进制文件进行链接, 生成可执行文件
	运行可执行文件
预处理指令
	预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件
	宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令
宏	
	定义一个宏时可以引用已经定义的宏名
	可用宏定义表示数据类型,使书写方便：
	#define String char 
	* String str = "This is a string!";
	C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参
	#define average(a, b) (a+b)/2 宏名和参数列表之间不能有空格
	int a = average(10, 4);
	带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。
	计算结果最好也用括号括起来
条件编译
	希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译
	如常量表达式的值为真(非0),则将code1 编译到程序中,否则对code2编译到程序中
typedef
	其中原类型名中含有定义部分,新类型名一般用大写表示,以便于区别。
	有时也可用宏定义来代替typedef的功能,但是宏定义是由预处理完成的,而typedef则是在编译 时完成的,后者更为灵活方便。
const关键字
	使用const修饰变量则可以让变量的值不能改变
	编译器通常不为普通const常量分配存储空间,而是将它们保存在符号表 中,这使得它成为一个编译期间的常量,没有了存储与读内存的操作
	int const x=2; 或 const int x=2;
	可以用指针间接修改变量中的值
	修饰常数组(值不能够再改变了)
	修饰函数的常参数
	const int *A; //const修饰指针,A可变,A指向的值不能被修改
	int const *A; //const修饰指向的对象,A可变,A指向的对象不可变
	int *const A; //const修饰指针A, A不可变,A指向的对象可变
	const int *const A;//指针A和A指向的对象都不可变
内存管理
	从高地址到低地址
	内核空间-栈区（用于存放局部变量）-堆区（存放malloc和new申请的空间）-未初始化区（未初始化全局变量）-初始化区（已初始化全局变量、静态变量、常量）-代码区
栈内存(Stack)
	栈中存放任意类型的变量，但必须是 auto 类型修饰的，即自动类型的局部变量， 随用随开，用完即消
	内存的分配和销毁系统自动完成，不需要人工干预
	栈的最大尺寸固定，超出则引起栈溢出，局部变量过多，过大 或 递归层数太多等就会导致栈溢出
	变量的初始化和内存分配遵循的是从栈顶（高地址）向栈底（低地址）的方向进行分配
堆内存
	堆内存可以存放任意类型的数据，但需要自己申请与释放
	堆大小，想像中的无穷大，但实际使用中，受限于实际内存的大小和内存是否连续性
malloc函数
	#include <stdlib.h>
	void * malloc(size_t _Size);  int *p = (int *)malloc(sizeof(int));
	申请堆内存空间并返回,所申请的空间并未初始化。
	通过memset 字节初始化。  memset(p, 0, sizeof(int)); // 对申请的内存空间进行初始化
free函数
	void free(void *p);
	释放申请的堆内存
	malloc和free函数总是成对出现
calloc函数
	void *calloc(size_t nmemb, size_t size);   int *p = calloc(3, sizeof(int));
	size_t nmemb 所需内存单元数量
	size_t size 内存单元字节数量
	申请堆内存空间并返回，所申请的空间，自动清零
realloc函数
	void *realloc(void *ptr, size_t size);
	扩容(缩小)原有内存的大小。通常用于扩容，缩小会会导致内存缩去的部分数据丢失。
	void * ptr 表示待扩容(缩小)的指针， ptr 为之前用 malloc 或者 calloc 分配的内存地址。
	size_t size 表示扩容(缩小)后内存的大小。
链表
	typedef struct node{
    int data;
    struct node *next; 可以引用自己的指针
	}Node;




	*/